"""
QuBee Knowledge Models for Stone Industry RAG Database
Stone-specific knowledge extraction and storage models
"""

from pydantic import BaseModel, Field
from typing import Dict, List, Optional, Any, Literal
from datetime import datetime
from enum import Enum
import uuid

class KnowledgeGapType(str, Enum):
    """Types of knowledge gaps QuBee can detect"""
    TECHNICAL_SPECS = "technical_specifications"
    PRACTICAL_DETAILS = "practical_details"
    PRICING_INFO = "pricing_information"
    INSTALLATION_GUIDE = "installation_guidelines"
    MAINTENANCE_TIPS = "maintenance_tips"
    ORIGIN_DETAILS = "origin_details"
    VISUAL_CHARACTERISTICS = "visual_characteristics"
    APPLICATIONS = "applications"
    AVAILABILITY = "availability"

class QuestionPriority(str, Enum):
    """Priority levels for QuBee questions"""
    CRITICAL = "critical"    # Affects TileScribe output quality
    HIGH = "high"           # Important for comprehensive knowledge
    MEDIUM = "medium"       # Nice-to-have details
    LOW = "low"             # Background information

class StoneKnowledgeGap(BaseModel):
    """Represents a knowledge gap for a specific stone"""
    gap_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    stone_name: str
    stone_type: str
    gap_type: KnowledgeGapType
    priority: QuestionPriority
    description: str
    suggested_question: str
    context: Dict[str, Any]
    source_system: str  # "tilescribe", "stonewiki", "manual"
    created_at: datetime = Field(default_factory=datetime.utcnow)
    resolved: bool = False
    resolution_content: Optional[str] = None

class StoneProfile(BaseModel):
    """Comprehensive stone profile in RAG database"""
    stone_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    stone_type: str  # Marble, Travertine, Limestone, etc.
    alternative_names: List[str] = []
    
    # Physical Characteristics
    origin: Optional[str] = None
    primary_color: Optional[str] = None
    veining_pattern: Optional[str] = None
    finish_types: List[str] = []
    density: Optional[float] = None
    porosity: Optional[str] = None
    
    # Technical Specifications
    compressive_strength: Optional[str] = None
    water_absorption: Optional[str] = None
    frost_resistance: Optional[str] = None
    slip_resistance: Optional[str] = None
    
    # Commercial Information
    availability: Optional[str] = None
    typical_price_range: Optional[str] = None
    market_position: Optional[str] = None
    rarity: Optional[str] = None
    
    # Applications
    recommended_applications: List[str] = []
    not_recommended_for: List[str] = []
    
    # Practical Information
    installation_notes: Optional[str] = None
    maintenance_requirements: Optional[str] = None
    common_issues: List[str] = []
    expert_tips: List[str] = []
    
    # Knowledge Sources
    expert_answers: List[Dict[str, Any]] = []
    last_updated: datetime = Field(default_factory=datetime.utcnow)
    completeness_score: float = 0.0  # 0-1 scale
    knowledge_gaps: List[str] = []  # List of gap_ids

class ExpertAnswer(BaseModel):
    """Expert answer collected via Telegram"""
    answer_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    question_id: str
    stone_name: str
    expert_telegram_id: str
    expert_name: Optional[str] = None
    answer_text: str
    confidence_score: float = Field(ge=0.0, le=1.0, default=0.8)
    verification_status: Literal["pending", "verified", "disputed"] = "pending"
    tags: List[str] = []
    created_at: datetime = Field(default_factory=datetime.utcnow)
    verified_by: Optional[str] = None
    verification_date: Optional[datetime] = None

class QuBeeQuestion(BaseModel):
    """Question generated by QuBee for expert input"""
    question_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    stone_name: str
    question_text: str
    question_type: KnowledgeGapType
    priority: QuestionPriority
    context: Dict[str, Any]
    
    # Telegram tracking
    sent_to_telegram: bool = False
    telegram_message_id: Optional[int] = None
    sent_at: Optional[datetime] = None
    
    # Response tracking
    answered: bool = False
    answer_id: Optional[str] = None
    answered_at: Optional[datetime] = None
    
    # Follow-up tracking
    needs_follow_up: bool = False
    follow_up_questions: List[str] = []
    
    created_at: datetime = Field(default_factory=datetime.utcnow)

class KnowledgeExtractionResult(BaseModel):
    """Result of processing expert answers into structured knowledge"""
    extraction_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    source_answer_id: str
    stone_name: str
    extracted_facts: List[Dict[str, Any]]
    confidence_scores: Dict[str, float]
    updated_fields: List[str]
    created_embeddings: List[str]
    processed_at: datetime = Field(default_factory=datetime.utcnow)

class QuBeeSession(BaseModel):
    """Telegram conversation session with expert"""
    session_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    expert_telegram_id: str
    expert_name: Optional[str] = None
    current_stone: Optional[str] = None
    current_question_id: Optional[str] = None
    session_state: Literal["idle", "answering", "clarifying", "reviewing"] = "idle"
    questions_answered: int = 0
    session_start: datetime = Field(default_factory=datetime.utcnow)
    last_activity: datetime = Field(default_factory=datetime.utcnow)
    session_data: Dict[str, Any] = {}

# RAG Database Document Models
class StoneDocument(BaseModel):
    """Document for vector storage in RAG database"""
    doc_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    stone_name: str
    content: str
    document_type: Literal["profile", "expert_answer", "technical_spec", "practical_tip"]
    metadata: Dict[str, Any]
    embedding_vector: Optional[List[float]] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

# Specific Stone Models for Priority Stones
class RossoLevantoProfile(StoneProfile):
    """Specialized profile for Rosso Levanto marble"""
    name: str = "Rosso Levanto"
    stone_type: str = "Marble"
    alternative_names: List[str] = ["Red Levanto", "Levanto Red", "Rosso Levanto Marble"]
    origin: str = "Liguria, Italy"
    primary_color: str = "Deep Red with White Veining"

class CalacattaViolaProfile(StoneProfile):
    """Specialized profile for Calacatta Viola marble"""
    name: str = "Calacatta Viola"
    stone_type: str = "Marble"
    alternative_names: List[str] = ["Calacatta Purple", "Viola Calacatta"]
    origin: str = "Carrara, Italy"
    primary_color: str = "White with Purple/Violet Veining"

# QuBee Workflow States
class QuBeeWorkflowState(BaseModel):
    """State for QuBee LangGraph workflow"""
    # Current processing context
    active_stone: Optional[str] = None
    knowledge_gaps: List[StoneKnowledgeGap] = []
    generated_questions: List[QuBeeQuestion] = []
    
    # Integration with other systems
    tilescribe_context: Optional[Dict[str, Any]] = None
    stonewiki_context: Optional[Dict[str, Any]] = None
    
    # Telegram interaction
    current_session: Optional[QuBeeSession] = None
    pending_answers: List[str] = []  # List of question_ids
    
    # Knowledge extraction
    new_expert_answers: List[ExpertAnswer] = []
    extraction_results: List[KnowledgeExtractionResult] = []
    
    # RAG database updates
    documents_to_create: List[StoneDocument] = []
    documents_to_update: List[str] = []
    
    # Workflow metadata
    workflow_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    workflow_state: Literal["analyzing_gaps", "generating_questions", "waiting_for_answers", "processing_answers", "updating_rag"] = "analyzing_gaps"
    started_at: datetime = Field(default_factory=datetime.utcnow)
    last_updated: datetime = Field(default_factory=datetime.utcnow)

# Priority Stones Configuration
PRIORITY_STONES = {
    "rosso_levanto": {
        "name": "Rosso Levanto",
        "type": "Marble",
        "priority": "critical",
        "known_gaps": [
            "quarry_location_specifics",
            "price_variations_by_grade",
            "installation_challenges",
            "maintenance_frequency"
        ]
    },
    "calacatta_viola": {
        "name": "Calacatta Viola", 
        "type": "Marble",
        "priority": "critical",
        "known_gaps": [
            "vein_pattern_variations",
            "availability_timeline",
            "matching_challenges",
            "finish_recommendations"
        ]
    },
    "carrara_white": {
        "name": "Carrara White",
        "type": "Marble", 
        "priority": "high",
        "known_gaps": [
            "grade_classifications",
            "quarry_differences",
            "seasonal_availability"
        ]
    }
}

# Question Templates for Specific Stones
STONE_QUESTION_TEMPLATES = {
    "rosso_levanto": [
        "What are the specific quarry locations for Rosso Levanto in Liguria?",
        "How does the quality vary between different Rosso Levanto suppliers?",
        "What are common installation challenges with Rosso Levanto?",
        "What's the typical price range for different grades of Rosso Levanto?",
        "How frequently does Rosso Levanto require maintenance and sealing?"
    ],
    "calacatta_viola": [
        "What are the different vein pattern variations in Calacatta Viola?",
        "How challenging is it to match Calacatta Viola slabs for large projects?",
        "What finish options work best for Calacatta Viola?",
        "What's the current availability and lead time for Calacatta Viola?",
        "Are there quality differences between Calacatta Viola suppliers?"
    ]
}